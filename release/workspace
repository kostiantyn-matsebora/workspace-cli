#!/usr/bin/env bash
# This script was generated by bashly 1.2.2 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
workspace_usage() {
  printf "workspace - Workspace cli\n\n"

  printf "%s\n" "Usage:"
  printf "  workspace COMMAND\n"
  printf "  workspace [COMMAND] --help | -h\n"
  printf "  workspace --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Setup (install and configure) workspace. Some of steps require interactive input, so this command cannot be used in CI/CD environments and automation scripts.\n" "setup  "
  printf "  %s   Configure workspace. Applications needs to be already installed. Some of steps require interactive input, so this command cannot be used in CI/CD environments and automation scripts.\n" "config "
  printf "  %s   Install applications and tools required for workspace. Does not require interactive input, so this command cannot be used in CI/CD environments and automation scripts.\n" "install"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
workspace_setup_usage() {
  if [[ -n $long_usage ]]; then
    printf "workspace setup\n\n"
    printf "  Setup (install and configure) workspace. Some of steps require interactive\n  input, so this command cannot be used in CI/CD environments and automation\n  scripts.\n\n"
  else
    printf "workspace setup - Setup (install and configure) workspace. Some of steps require interactive input, so this command cannot be used in CI/CD environments and automation scripts.\n\n"
  fi
  printf "Alias: s\n"
  echo

  printf "%s\n" "Usage:"
  printf "  workspace setup [APPLICATION]\n"
  printf "  workspace setup --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "APPLICATION"
    printf "    Application  or toolkit needs to be setup. Possible values: all, git,\n    docker, k3s, minikube, kube-tools, vscode, vals\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  workspace setup git // Install and configure git\n"
    printf "  workspace setup all // Install and configure all applications\n"
    echo

  fi
}

# :command.usage
workspace_config_usage() {
  printf "workspace config - Configure workspace. Applications needs to be already installed. Some of steps require interactive input, so this command cannot be used in CI/CD environments and automation scripts.\n\n"
  printf "Alias: c\n"
  echo

  printf "%s\n" "Usage:"
  printf "  workspace config [APPLICATION]\n"
  printf "  workspace config --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "APPLICATION"
    printf "    Application or toolkit needs to be configured. Possible values: all, git,\n    kubeconfig, vals.\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  workspace config git // Configure git toolkit\n"
    printf "  workspace config all // Configure all applications\n"
    echo

  fi
}

# :command.usage
workspace_install_usage() {
  if [[ -n $long_usage ]]; then
    printf "workspace install\n\n"
    printf "  Install applications and tools required for workspace. Does not require\n  interactive input, so this command cannot be used in CI/CD environments and\n  automation scripts.\n\n"
  else
    printf "workspace install - Install applications and tools required for workspace. Does not require interactive input, so this command cannot be used in CI/CD environments and automation scripts.\n\n"
  fi
  printf "Alias: i\n"
  echo

  printf "%s\n" "Usage:"
  printf "  workspace install [APPLICATION] [OPTIONS]\n"
  printf "  workspace install --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--yes, -y"
    printf "    Automatic mode, does not require interactive input. Useful for CI/CD\n    environments and automation scripts.\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "APPLICATION"
    printf "    Application or toolkit needs to be installed. Possible values: all, git,\n    docker, k3s, minikube, kube-tools, vscode, vals\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  workspace install git // Install git, interactive mode\n"
    printf "  workspace install all -y // Install all applications, automatic mode\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# ./src/actions/cleanup_system.sh
#! /bin/bash

cleanup_system() {
	# Running autoremove to remove unnecessary packages
	echo "Running autoremove"
	sudo apt-get autoremove -y

	# Removing apt package cache
	echo "Removing apt package cache"
	sudo apt-get clean

	# Getting the size of journalctl logs
	echo "Getting the size of journalctl logs"
	journalctl --disk-usage

	# Removing journalctl logs older than 3 days
	echo "Removing journalctl logs older than 3 days"
	sudo journalctl --vacuum-time=3d

	STACER_INSTALLED="N"
	# Checking if stacer is installed
	if [ -e /usr/bin/stacer ]
	then

		echo "Stacer is installed"
		STACER_INSTALLED="Y"
	else
		read -sn 1 -p "Do you want to install stacer? [y/n]" INSTALL_STACER
		echo -e "\n"
		if [[ "$INSTALL_STACER" = "Y" || "$INSTALL_STACER" = "y" ]]
		then
			# Installing stacer
			echo "Installing stacer"
			sudo apt-get install stacer -y
			if [ "$?" -eq "0" ]
			then
				STACER_INSTALLED="Y"
			fi
		fi
	fi

	if [[ "$STACER_INSTALLED" = "Y" ]]
	then
		read -sn 1 -p "Do you want to run stacer to clean up system?" RUN_STACER
		if [[ "$RUN_STACER" = "Y" || "$RUN_STACER" = "y" ]]
		then
			stacer &
		fi
	fi

	# Getting list of timeshift snapshots
	echo "Getting list of timeshift snapshots"
	sudo timeshift --list

	echo "Use timeshift delete --snapshot 'snapshot_name' to delete a snapshot"
	echo "Also you can use sudo rm -rfv /timeshift/snapshots/snapshot_name to delete a snapshot"
}

# ./src/actions/configure/configure_git.sh
#!/bin/bash

configure_git() {
    echo_info "Configure git"

    yes_or_no "Do you want to set global username and email for git?"
    if [ $? -eq 0 ]
    then
        USERNAME=$(read_input "Enter your username: ")
        git config --global user.name "$USERNAME"
        exit_if_error "Error setting global username"

        EMAIL=$(read_input "Enter your email: ")
        git config --global user.email "$EMAIL"
        exit_if_error "Error setting global email"
    fi

    yes_or_no "Do you want to generate ssh keys for github?"
    GENERATESSHKEYS=$?

    while [ $GENERATESSHKEYS -eq 0 ]
    do
        if [ ! -d ~/.ssh ]
        then
            mkdir ~/.ssh
        fi
        exit_if_error "Error creating ssh directory"

        EMAIL=$(read_input "Enter your email: ")
        FILENAME="${HOME}/.ssh/${EMAIL}_rsa"
        ssh-keygen -t rsa -b 4096 -C "$EMAIL" -f "$FILENAME"
        exit_if_error "Error generating ssh key"

        yes_or_no "Do you want to add host definition and key to ssh config?"

        if [ $? -eq 0 ]
        then
            GITHUBHOST="github.com"
            HOST=$(read_input "Enter host name ($GITHUBHOST as default, could also be ${GITHUBHOST}-something to use different ssh keys for different repos): ")
            if [ -z "$HOST" ]
            then
                HOST=$GITHUBHOST
            fi
            echo "Host $HOST" >> ~/.ssh/config &&
            echo "  HostName $GITHUBHOST" >> "$HOME"/.ssh/config &&
            echo "  User git" >> ~/.ssh/config &&
            echo "  IdentityFile $FILENAME" >> "$HOME"/.ssh/config

        fi
        exit_if_error "Error adding host definition and key to ssh config"

        yes_or_no "Do you want to generate another ssh key?"
        GENERATESSHKEYS=$?

        if [ $GENERATESSHKEYS -ne 0 ]
        then
            echo_message "Your ssh configuration is:"
            cat "${HOME}/.ssh/config"
            exit_if_error "Error reading ssh config"

            echo_message "Your ssh keys and configuration are:"
            ls -l "$HOME/.ssh"
            exit_if_error "Error reading ssh config"
            echo_info "Do not forget to add generated ssh keys to your github account using following instruction: https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account"
            press_any_key
        fi
    done
}

# ./src/actions/configure/configure_grub_menu.sh
#!/bin/bash


configure_grub_menu() {
	echo_info "Beautify Grub menu"

	yes_or_no "Do you want to beautify Grub menu?"
	exit_if_answer_no

	echo_message "Beautify Grub menu for Linux Mint"
	apt install --reinstall -o Dpkg::Options::="--force-confmiss" grub2-theme-mint2k
}

# ./src/actions/configure/configure_kubeconfig.sh
#!/bin/bash

configure_kubeconfig() {
    echo_info "Configure kubectl to use k3s"

    if [ -e /etc/rancher/k3s/k3s.yaml ]
    then
        yes_or_no "Do you want to configure kubectl to use k3s?" "$AUTOMATIC_MODE"
        if [[ $? -eq 0 ]]
        then
            echo_message "Configuring kubectl to use k3s"
            mkdir -p ~/.kube
            exit_if_error "Error configuring kubectl to use k3s"
            if [ -e ~/.kube/config ]
            then
                echo_message "Backing up existing kubectl configuration"
                mv ~/.kube/config ~/.kube/config.bak
                exit_if_error "Error configuring kubectl to use k3s"
            fi

            echo_message "Copying k3s configuration  as kubectl configuration"
            cp /etc/rancher/k3s/k3s.yaml ~/.kube/config &&
            chmod go-r ~/.kube/config &&
            kubectl config set-context default &&
            kubectl config use-context default
            exit_if_error "Error configuring kubectl to use k3s"
        else
            echo_message "Skipping k3s configuration"
        fi
    fi
}

# ./src/actions/configure/configure_vals_vault.sh
#!/bin/bash

configure_vals_vault() {
    echo_info "Configure vals for using Hashicorp Vault as secrets store"

    yes_or_no "Do you want to vals for using Hashicorp Vault as secrets store?"

    if [[ $? -eq 0 ]]
    then
        # Prompt the user for Vault URL and token
        VAULT_ADDR=$(read_input "Enter Hashicorp Vault URL: ")
        VAULT_TOKEN=$(read_input "Enter Vault Token: ")

        # Add the environment variables to .bashrc
        echo "export VAULT_ADDR=$VAULT_ADDR" >> ~/.bashrc
        echo "export VAULT_TOKEN=$VAULT_TOKEN" >> ~/.bashrc
        echo "export VAULT_AUTH_METHOD=token" >> ~/.bashrc

        # Inform the user
        echo "Vault URL and token have been added to ~/.bashrc"

        # Source the .bashrc to apply changes immediately
        source ~/.bashrc
    fi
}

# ./src/actions/install/install_bashly.sh
#!/bin/bash

install_bashly() {
	echo_info "Configure shell to run bashly commands as a Docker container"

	echo "alias bashly='docker run --rm -it --volume "$PWD:/app" dannyben/bashly'" >> ~/.bashrc
	source ~/.bashrc
}

# ./src/actions/install/install_git_toolkit.sh
#!/bin/bash


# Include functions
install_git_toolkit() {

    AUTOMATIC_MODE=$(is_automatic_mode "$1")

    echo_info "Installing git and github CLI"

    yes_or_no "Do you want to install git?" "$AUTOMATIC_MODE"

    if [[ $? -eq 0 ]]
    then
        echo_message "Installing git"
        sudo apt install git -y
    else
        echo_message "Skipping git installation"
    fi
    exit_if_error "Error installing git"

    yes_or_no "Do you want to install github CLI?" "$AUTOMATIC_MODE"

    if [[ $? -eq 0 ]]
    then
        echo_message "Installing github CLI"
        sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-key C99B11DEB97541F0 &&
        sudo apt-add-repository https://cli.github.com/packages -y &&
        sudo apt update && -y
        sudo apt install gh -y
    else
        echo_message "Skipping github CLI installation"
    fi

    if [ $AUTOMATIC_MODE -eq 0 ]
    then
        exit 0
    fi

}

# ./src/actions/install/install_k3s.sh
#!/bin/bash

#   - automatic
install_k3s() {
    AUTOMATIC_MODE=$(is_automatic_mode "$1")

    echo_info "Installing and configuring k3s"

    yes_or_no "Do you want to install k3s?" "$AUTOMATIC_MODE"

    if [[ $? -eq 0 ]]
    then
        if [-e /usr/local/bin/ufw ]
        then
            echo_message "Adding firewall rules for k3s"
            ufw allow 6443/tcp && #apiserver
            ufw allow from 10.42.0.0/16 to any && #pods
            ufw allow from 10.43.0.0/16 to any #services
            exit_if_error "Error adding firewall rules for k3s"
        fi

        echo_message "Installing k3s"
        curl -sfL https://get.k3s.io | K3S_KUBECONFIG_MODE="644" INSTALL_K3S_EXEC="server" sh -s - --flannel-backend vxlan
        exit_if_error "Error installing k3s"
    else
        echo_message "Skipping k3s installation"
    fi
}

# ./src/actions/install/install_kubernetes_toolkit.sh
#!/bin/bash

# Supported modes:
#  - interactive
#  - automatic
install_kubernetes_toolkit() {
  AUTOMATIC_MODE=$(is_automatic_mode "$1")
  echo_info "Installing  and configuring kubernetes tools."

  INSTALL_KUBECTL=0
  if [ -e /usr/local/bin/kubectl ]
  then
  echo_message "Kubectl is already installed."
  yes_or_no "Do you want to reinstall/upgrade kubectl?" "$AUTOMATIC_MODE"
  INSTALL_KUBECTL=$?
  fi

  if [[ "$INSTALL_KUBECTL" = "0" ]]
  then
      echo_message "Installing kubectl"
      curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl" &&
      sudo mv ./kubectl /usr/local/bin
      exit_if_error "Error installing kubectl"
  fi

  if [ -e /usr/local/bin/kubectl ]
  then
    echo_message "Configuring kubectl autocompletion"
    kubectl completion bash > ~/.kubectl_completion &&
    echo "source ~/.kubectl_completion" >> ~/.bashrc &&
    source ~/.kubectl_completion
    exit_if_error "Error configuring kubectl autocompletion"
  fi

  INSTALL_HELM=0

  if [ -e /usr/local/bin/helm ]
  then
  echo_message "Helm is already installed."
  yes_or_no "Do you want to reinstall/upgrade helm?" "$AUTOMATIC_MODE"
  INSTALL_HELM=$?
  fi

  # Install helm
  if [[ "$INSTALL_HELM" = "0" ]]
  then
      echo_message "Installing helm"
      curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3 &&
      chmod 700 get_helm.sh &&
      ./get_helm.sh
      exit_if_error "Error installing helm"

      echo_message "Cleaning up"
      rm -f get_helm.sh
  fi

  # Configure helm completion
  if [ -e /usr/local/bin/helm ]
  then
    echo_message "Configuring helm autocompletion"
    helm completion bash > ~/.helm_completion &&
    echo "source ~/.helm_completion" >> ~/.bashrc &&
    source ~/.helm_completion
    exit_if_error "Error configuring helm autocompletion"
  fi

  # Install and configure helmfile
  INSTALL_HELMFILE=0

  if [ -e /usr/local/bin/helmfile ]
  then
  echo_message "Helmfile is already installed."
  yes_or_no "Do you want to reinstall/upgrade helmfile?" "$AUTOMATIC_MODE"
  INSTALL_HELMFILE=$?
  else

  yes_or_no "Do you want to install helmfile?" "$AUTOMATIC_MODE"
  INSTALL_HELMFILE=$?
  fi

  if [[ "$INSTALL_HELMFILE" = "0" ]]
  then
      echo_message "Installing helmfile"
      HELMFILE_URL="https://github.com/helmfile/helmfile/releases/download/v0.168.0/helmfile_0.168.0_linux_amd64.tar.gz"

      DEST_DIR="/usr/local/bin"
      curl -L $HELMFILE_URL -o helmfile.tar.gz &&
      sudo tar -xzf helmfile.tar.gz -C $DEST_DIR &&
      rm helmfile.tar.gz
      exit_if_error "Error installing helmfile"
  fi
}

# ./src/actions/install/install_minikube.sh

#!/bin/bash

install_minikube() {
    AUTOMATIC_MODE=$(is_automatic_mode "$1")

    echo_info "Install minikube"

    # Install minikube (driver=docker runtime=containerd)
    yes_or_no "Do you want to install minikube (driver=docker containerd and all depedencies?" "$AUTOMATIC_MODE"

    if [[ $? -eq 0 ]]
    then
        INSTALL_MINIKUBE=0

        if [ -e /usr/local/bin/minikube ]
        then
        echo_message "Minikube is already installed."
        yes_or_no "Do you want to reinstall minikube?" "$AUTOMATIC_MODE"
        INSTALL_MINIKUBE=$?
        fi

        if [[ "$INSTALL_MINIKUBE" = "0" ]]
        then
            echo_message "Installing Minikube"
            curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
            sudo install minikube-linux-amd64 /usr/local/bin/minikube &&

            rm minikube-linux-amd64 &&

            echo_message "Making docker default driver for minikube" &&
            minikube config set driver docker &&

            echo_message "Making containerd default container runtime for minikube" &&
            minikube config set container-runtime containerd

            exit_if_error "Error installing and configuring Minikube"
        fi

        echo_message "Minikube installation and configuration is completed."
        echo_message "If you already have VMs, you need to delete them using command: minikube delete"
        echo_message "To run minikube, use command: minikube start"
    fi
}

# ./src/actions/install/install_rootless_docker.sh
#!/bin/bash

install_rootless_docker() {

    AUTOMATIC_MODE=$(is_automatic_mode "$1")

    echo_info "Installing and configuring rootless docker and docker-compose"

    yes_or_no "Do you want to install rootless docker (roothless docker + containerd + buildkit)?" "$AUTOMATIC_MODE"

    if [ $? -eq 0 ]

    then
        # Install dependencies
    echo_message "Installing docker"
    curl -o install.sh -fsSL https://get.docker.com
    sudo sh install.sh
    exit_if_error "Error installing docker"

    # Setup rootless docker
        echo_message "Setting up rootless docker"
        dockerd-rootless-setuptool.sh install
        exit_if_error "Error setting up rootless docker"

        # Cleanup
        echo_message "Cleaning up"
        rm -f install.sh
        exit_if_error "Error cleaning up"

        # Installing docker-compose
        echo_message "Installing docker-compose"
        sudo apt install docker-compose -y
    fi
}

# ./src/actions/install/install_vals.sh
#!/bin/bash

install_vals() {
    AUTOMATIC_MODE=$(is_automatic_mode "$1")
    echo_info "Install vals (https://github.com/helmfile/vals)"

    INSTALL_VALS=0

    if [ -e /usr/local/bin/vals ]
    then
    echo_message "Vals is already installed."
    yes_or_no "Do you want to reinstall/upgrade vals?" "$AUTOMATIC_MODE"
    INSTALL_VALS=$?
    else

    yes_or_no "Do you want to install vals?" "$AUTOMATIC_MODE"
    INSTALL_VALS=$?
    fi

    if [[ "$INSTALL_VALS" = "0" ]]
    then
        echo_message "Installing vals"
        VALS_URL="https://github.com/helmfile/vals/releases/download/v0.37.5/vals_0.37.5_linux_amd64.tar.gz"
        DEST_DIR="/usr/local/bin"
        curl -L $VALS_URL -o vals.tar.gz &&
        sudo tar -xzf vals.tar.gz -C $DEST_DIR &&
        rm vals.tar.gz
        exit_if_error "Error installing vals"
    fi
}

# ./src/actions/install/install_vscode.sh
#!/bin/bash

install_vscode() {
    AUTOMATIC_MODE=$(is_automatic_mode "$1")

    echo_info "Installing and configuring VSCode"

    yes_or_no "Do you want to install VSCode?" "$AUTOMATIC_MODE"
    if [[ $? -eq 0 ]]
    then
        echo_message "Installing VSCode"
        sudo apt-get install  -y wget gpg
        wget -qO- https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor > packages.microsoft.gpg
        sudo install -D -o root -g root -m 644 packages.microsoft.gpg /etc/apt/keyrings/packages.microsoft.gpg
        echo "deb [arch=amd64,arm64,armhf signed-by=/etc/apt/keyrings/packages.microsoft.gpg] https://packages.microsoft.com/repos/code stable main" |sudo tee /etc/apt/sources.list.d/vscode.list > /dev/null
        rm -f packages.microsoft.gpg

        sudo apt install  -y apt-transport-https
        sudo apt  -y update
        sudo apt install -y code
    else
        echo_message "Skipping VSCode installation"
    fi
    exit_if_error "Error installing VSCode"

    yes_or_no "Do you want to install shellcheck?" "$AUTOMATIC_MODE"

    if [[ $? -eq 0 ]]

    then
        echo_message "Installing shellcheck"
        sudo apt update &&
        sudo apt install -y shellcheck
    else
        echo_message "Skipping shellcheck installation"
    fi
}

# ./src/actions/sync_onedrive.sh
#!/bin/bash

sync_onedrive() {
	onedrive --skip-dir "Docs|Pictures" --synchronize --download-only
}

# ./src/actions/update_system.sh
#! /bin/bash





update_system() {

	echo_message "Update packages to latest version"

	apt update && apt upgrade -y

	exit_if_error "Error occured during update of system"

}

# ./src/functions/colors.sh
print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

# ./src/functions/setup.sh
#!/bin/bash

setup_git() {
    install_git $1 &&
    config_git
}

setup_kubernetes_toolkit() {
    install_kubernetes_toolkit $1 &&

    config_kubeconfig

}

setup_k3s() {
    install_k3s $1 &&

    config_kubeconfig

}

setup_vals() {
    install_vals $1 &&
    config_vals_vault
}

# ./src/functions/shared.sh
#!/bin/bash

timestamp() {
  date +%F_%T # current date and time
}

green() {
    echo -e "\033[0;32m$1\033[0m"
}

yellow_bold() {
    echo -e "\033[1;33m$1\033[0m"
}

red() {
    echo -e "\033[0;31m$1\033[0m"
}

green_bold() {
    echo -e "\033[1;92m$1\033[0m"
}

echo_message(){
    echo -e "$(green "[$(timestamp)] $1\n")"
}

echo_info(){
    echo -e "\n"
    echo -e "$(yellow_bold "[$(timestamp)] $1\n")"

}

echo_error(){
    echo -e "$(red "[$(timestamp)] $1\n")"
    echo -e "\n"
}

function question(){
    local MESSAGE
    MESSAGE=$(green_bold "[$(timestamp)] $1\n")

    read -sn 1 -r -p "$MESSAGE" ANSWER
    echo  "$ANSWER"
}

function read_input(){
    local MESSAGE
    MESSAGE=$(green_bold "[$(timestamp)] $1")

    read -r -p "$MESSAGE" ANSWER
    echo  "$ANSWER"
}

function read_input(){
    local MESSAGE
    MESSAGE=$(green_bold "[$(timestamp)] $1")

    read -r -p "$MESSAGE" ANSWER
    echo  "$ANSWER"
}

function exit_if_error(){
    if [ "$?" -ne "0" ]
    then
        echo_error "$1"
        exit $?
    fi
}

function yes_or_no(){
    if [[ "$2" == "0" ]]
    then
        return 0
    fi

    local ANSWER
    ANSWER=$(question "$1 [y/n]")
    if [[ "$ANSWER" = "y" || "$ANSWER" = "Y" ]]
    then
        return 0
    else
        return 1
    fi
}

function exit_if_answer_no() {
    if [[ $? -ne 0 ]]
    then
        echo_message "Exiting..."
        exit 0
    fi
}

function is_automatic_mode(){
    if [[ "$1" == "--yes" || "$1" == "-y" ]]
    then
        echo 0
    else
        echo 1
    fi
}

function press_any_key(){
    read -n 1 -s -r -p "Press any key to continue..."
}

# ./src/functions/workspace.sh
#!/bin/bash
workspace_app() {
    local WORKSPACE_APP="${args[application]}"
    echo $WORKSPACE_APP
}

workspace_yes() {
    if [ -z "${args[--yes]}" ]; then
        return
    else

        echo "--yes"
    fi
}

# :command.command_functions
# :command.function
workspace_setup_command() {
  # ./bashly/commands/setup.sh
  #!/bin/bash
  inspect_args
  WORKSPACE_APP="$(workspace_app)"
  WORKSPACE_YES="$(workspace_yes)"

  case "$WORKSPACE_APP" in
    "git")
      install_git_toolkit "$WORKSPACE_YES"
      ;;
    "docker")
      install_rootless_docker "$WORKSPACE_YES"
      ;;
    "k3s")
      setup_k3s
      ;;
    "minikube")
       install_minikube "$WORKSPACE_YES"
       ;;
    "kube-tools")
       setup_kubernetes_toolkit "$WORKSPACE_YES"
       ;;
    "vals")
       setup_vals "$WORKSPACE_YES"
       ;;

    "vscode")
       install_vscode "$WORKSPACE_YES"
       ;;
    "all")
       install_git_toolkit "$WORKSPACE_YES" &&
       install_vscode "$WORKSPACE_YES" &&
       install_rootless_docker "$WORKSPACE_YES" &&
       setup_k3s "$WORKSPACE_YES" &&
       setup_kubernetes_toolkit "$WORKSPACE_YES" &&
       setup_vals "$WORKSPACE_YES"
  esac

}

# :command.function
workspace_config_command() {
  # ./bashly/commands/config.sh
  #!/bin/bash
  WORKSPACE_APP="$(workspace_app)"

  case "$WORKSPACE_APP" in
    "git")
      # Configure git
      configure_git
      ;;
    "kubeconfig")
      # Configure kubernetes config file
      configure_kubeconfig
      ;;
    "vals")
      # Configure vals for using Hashicorp Vault as secrets store
      configure_vals
      ;;
    "grub-menu")
      # Configure grub menu
      configure_grub_menu
      ;;
    "all")
      configure_git
      configure_kubeconfig
      configure_vals
      ;;
  esac

}

# :command.function
workspace_install_command() {
  # ./bashly/commands/install.sh
  inspect_args

  WORKSPACE_APP="$(workspace_app)"
  WORKSPACE_YES="$(workspace_yes)"

  case "$WORKSPACE_APP" in
    "git")
      install_git_toolkit "$WORKSPACE_YES"
      ;;
    "docker")
      install_rootless_docker "$WORKSPACE_YES"
      ;;
    "k3s")
      install_k3s "$WORKSPACE_YES"
      ;;
    "minikube")
       install_minikube "$WORKSPACE_YES"
       ;;
    "kube-tools")
       install_kubernetes_toolkit "$WORKSPACE_YES"
       ;;
    "vals")
       install_vals "$WORKSPACE_YES"
       ;;

    "vscode")
       install_vscode "$WORKSPACE_YES"
       ;;
    "all")
       install_git_toolkit "$WORKSPACE_YES" &&
       install_vscode "$WORKSPACE_YES" &
       install_rootless_docker "$WORKSPACE_YES" &&
       install_k3s "$WORKSPACE_YES" &&
       install_kubernetes_toolkit "$WORKSPACE_YES" &&
       install_vals "$WORKSPACE_YES"
  esac

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        workspace_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    setup | s)
      action="setup"
      shift
      workspace_setup_parse_requirements "$@"
      shift $#
      ;;

    config | c)
      action="config"
      shift
      workspace_config_parse_requirements "$@"
      shift $#
      ;;

    install | i)
      action="install"
      shift
      workspace_install_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      workspace_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
workspace_setup_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        workspace_setup_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="setup"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['application']+x} ]]; then
          args['application']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
workspace_config_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        workspace_config_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="config"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['application']+x} ]]; then
          args['application']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
workspace_install_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        workspace_install_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="install"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --yes | -y)

        # :flag.case_no_arg
        args['--yes']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['application']+x} ]]; then
          args['application']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  version="0.2.0"
  long_usage=''

}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a env_var_names=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "setup") workspace_setup_command ;;
    "config") workspace_config_command ;;
    "install") workspace_install_command ;;
  esac
}

initialize
run "$@"
